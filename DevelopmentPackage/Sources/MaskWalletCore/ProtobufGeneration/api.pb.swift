// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: api.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct Api_MWRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var request: Api_MWRequest.OneOf_Request? = nil

  public var paramLoadStoredKey: Api_LoadStoredKeyParam {
    get {
      if case .paramLoadStoredKey(let v)? = request {return v}
      return Api_LoadStoredKeyParam()
    }
    set {request = .paramLoadStoredKey(newValue)}
  }

  public var paramCreateStoredKey: Api_CreateStoredKeyParam {
    get {
      if case .paramCreateStoredKey(let v)? = request {return v}
      return Api_CreateStoredKeyParam()
    }
    set {request = .paramCreateStoredKey(newValue)}
  }

  public var paramImportPrivateKey: Api_ImportPrivateStoredKeyParam {
    get {
      if case .paramImportPrivateKey(let v)? = request {return v}
      return Api_ImportPrivateStoredKeyParam()
    }
    set {request = .paramImportPrivateKey(newValue)}
  }

  public var paramImportMnemonic: Api_ImportMnemonicStoredKeyParam {
    get {
      if case .paramImportMnemonic(let v)? = request {return v}
      return Api_ImportMnemonicStoredKeyParam()
    }
    set {request = .paramImportMnemonic(newValue)}
  }

  public var paramImportJson: Api_ImportJSONStoredKeyParam {
    get {
      if case .paramImportJson(let v)? = request {return v}
      return Api_ImportJSONStoredKeyParam()
    }
    set {request = .paramImportJson(newValue)}
  }

  public var paramCreateAccountOfCoinAtPath: Api_CreateStoredKeyNewAccountAtPathParam {
    get {
      if case .paramCreateAccountOfCoinAtPath(let v)? = request {return v}
      return Api_CreateStoredKeyNewAccountAtPathParam()
    }
    set {request = .paramCreateAccountOfCoinAtPath(newValue)}
  }

  public var paramExportPrivateKey: Api_ExportKeyStorePrivateKeyParam {
    get {
      if case .paramExportPrivateKey(let v)? = request {return v}
      return Api_ExportKeyStorePrivateKeyParam()
    }
    set {request = .paramExportPrivateKey(newValue)}
  }

  public var paramExportPrivateKeyOfPath: Api_ExportKeyStorePrivateKeyOfPathParam {
    get {
      if case .paramExportPrivateKeyOfPath(let v)? = request {return v}
      return Api_ExportKeyStorePrivateKeyOfPathParam()
    }
    set {request = .paramExportPrivateKeyOfPath(newValue)}
  }

  public var paramExportMnemonic: Api_ExportKeyStoreMnemonicParam {
    get {
      if case .paramExportMnemonic(let v)? = request {return v}
      return Api_ExportKeyStoreMnemonicParam()
    }
    set {request = .paramExportMnemonic(newValue)}
  }

  public var paramExportKeyStoreJsonOfAddress: Api_ExportKeyStoreJSONOfAddressParam {
    get {
      if case .paramExportKeyStoreJsonOfAddress(let v)? = request {return v}
      return Api_ExportKeyStoreJSONOfAddressParam()
    }
    set {request = .paramExportKeyStoreJsonOfAddress(newValue)}
  }

  public var paramExportKeyStoreJsonOfPath: Api_ExportKeyStoreJSONOfPathParam {
    get {
      if case .paramExportKeyStoreJsonOfPath(let v)? = request {return v}
      return Api_ExportKeyStoreJSONOfPathParam()
    }
    set {request = .paramExportKeyStoreJsonOfPath(newValue)}
  }

  public var paramUpdateKeyStorePassword: Api_UpdateStoredKeyPasswordParam {
    get {
      if case .paramUpdateKeyStorePassword(let v)? = request {return v}
      return Api_UpdateStoredKeyPasswordParam()
    }
    set {request = .paramUpdateKeyStorePassword(newValue)}
  }

  public var paramSignTransaction: Api_SignTransactionParam {
    get {
      if case .paramSignTransaction(let v)? = request {return v}
      return Api_SignTransactionParam()
    }
    set {request = .paramSignTransaction(newValue)}
  }

  public var paramGetVersion: Api_GetVersionParam {
    get {
      if case .paramGetVersion(let v)? = request {return v}
      return Api_GetVersionParam()
    }
    set {request = .paramGetVersion(newValue)}
  }

  public var paramValidation: Api_ValidateParam {
    get {
      if case .paramValidation(let v)? = request {return v}
      return Api_ValidateParam()
    }
    set {request = .paramValidation(newValue)}
  }

  public var paramGetStoredKeyImportType: Api_GetKeyStoreSupportImportTypeParam {
    get {
      if case .paramGetStoredKeyImportType(let v)? = request {return v}
      return Api_GetKeyStoreSupportImportTypeParam()
    }
    set {request = .paramGetStoredKeyImportType(newValue)}
  }

  public var paramGetStoredKeyExportType: Api_GetKeyStoreSupportExportTypeParam {
    get {
      if case .paramGetStoredKeyExportType(let v)? = request {return v}
      return Api_GetKeyStoreSupportExportTypeParam()
    }
    set {request = .paramGetStoredKeyExportType(newValue)}
  }

  public var paramGenerateMnemonic: Api_GenerateMnemonicParam {
    get {
      if case .paramGenerateMnemonic(let v)? = request {return v}
      return Api_GenerateMnemonicParam()
    }
    set {request = .paramGenerateMnemonic(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Request: Equatable {
    case paramLoadStoredKey(Api_LoadStoredKeyParam)
    case paramCreateStoredKey(Api_CreateStoredKeyParam)
    case paramImportPrivateKey(Api_ImportPrivateStoredKeyParam)
    case paramImportMnemonic(Api_ImportMnemonicStoredKeyParam)
    case paramImportJson(Api_ImportJSONStoredKeyParam)
    case paramCreateAccountOfCoinAtPath(Api_CreateStoredKeyNewAccountAtPathParam)
    case paramExportPrivateKey(Api_ExportKeyStorePrivateKeyParam)
    case paramExportPrivateKeyOfPath(Api_ExportKeyStorePrivateKeyOfPathParam)
    case paramExportMnemonic(Api_ExportKeyStoreMnemonicParam)
    case paramExportKeyStoreJsonOfAddress(Api_ExportKeyStoreJSONOfAddressParam)
    case paramExportKeyStoreJsonOfPath(Api_ExportKeyStoreJSONOfPathParam)
    case paramUpdateKeyStorePassword(Api_UpdateStoredKeyPasswordParam)
    case paramSignTransaction(Api_SignTransactionParam)
    case paramGetVersion(Api_GetVersionParam)
    case paramValidation(Api_ValidateParam)
    case paramGetStoredKeyImportType(Api_GetKeyStoreSupportImportTypeParam)
    case paramGetStoredKeyExportType(Api_GetKeyStoreSupportExportTypeParam)
    case paramGenerateMnemonic(Api_GenerateMnemonicParam)

  #if !swift(>=4.1)
    public static func ==(lhs: Api_MWRequest.OneOf_Request, rhs: Api_MWRequest.OneOf_Request) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.paramLoadStoredKey, .paramLoadStoredKey): return {
        guard case .paramLoadStoredKey(let l) = lhs, case .paramLoadStoredKey(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.paramCreateStoredKey, .paramCreateStoredKey): return {
        guard case .paramCreateStoredKey(let l) = lhs, case .paramCreateStoredKey(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.paramImportPrivateKey, .paramImportPrivateKey): return {
        guard case .paramImportPrivateKey(let l) = lhs, case .paramImportPrivateKey(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.paramImportMnemonic, .paramImportMnemonic): return {
        guard case .paramImportMnemonic(let l) = lhs, case .paramImportMnemonic(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.paramImportJson, .paramImportJson): return {
        guard case .paramImportJson(let l) = lhs, case .paramImportJson(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.paramCreateAccountOfCoinAtPath, .paramCreateAccountOfCoinAtPath): return {
        guard case .paramCreateAccountOfCoinAtPath(let l) = lhs, case .paramCreateAccountOfCoinAtPath(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.paramExportPrivateKey, .paramExportPrivateKey): return {
        guard case .paramExportPrivateKey(let l) = lhs, case .paramExportPrivateKey(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.paramExportPrivateKeyOfPath, .paramExportPrivateKeyOfPath): return {
        guard case .paramExportPrivateKeyOfPath(let l) = lhs, case .paramExportPrivateKeyOfPath(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.paramExportMnemonic, .paramExportMnemonic): return {
        guard case .paramExportMnemonic(let l) = lhs, case .paramExportMnemonic(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.paramExportKeyStoreJsonOfAddress, .paramExportKeyStoreJsonOfAddress): return {
        guard case .paramExportKeyStoreJsonOfAddress(let l) = lhs, case .paramExportKeyStoreJsonOfAddress(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.paramExportKeyStoreJsonOfPath, .paramExportKeyStoreJsonOfPath): return {
        guard case .paramExportKeyStoreJsonOfPath(let l) = lhs, case .paramExportKeyStoreJsonOfPath(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.paramUpdateKeyStorePassword, .paramUpdateKeyStorePassword): return {
        guard case .paramUpdateKeyStorePassword(let l) = lhs, case .paramUpdateKeyStorePassword(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.paramSignTransaction, .paramSignTransaction): return {
        guard case .paramSignTransaction(let l) = lhs, case .paramSignTransaction(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.paramGetVersion, .paramGetVersion): return {
        guard case .paramGetVersion(let l) = lhs, case .paramGetVersion(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.paramValidation, .paramValidation): return {
        guard case .paramValidation(let l) = lhs, case .paramValidation(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.paramGetStoredKeyImportType, .paramGetStoredKeyImportType): return {
        guard case .paramGetStoredKeyImportType(let l) = lhs, case .paramGetStoredKeyImportType(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.paramGetStoredKeyExportType, .paramGetStoredKeyExportType): return {
        guard case .paramGetStoredKeyExportType(let l) = lhs, case .paramGetStoredKeyExportType(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.paramGenerateMnemonic, .paramGenerateMnemonic): return {
        guard case .paramGenerateMnemonic(let l) = lhs, case .paramGenerateMnemonic(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

public struct Api_MWResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var response: Api_MWResponse.OneOf_Response? = nil

  public var error: Api_MWResponseError {
    get {
      if case .error(let v)? = response {return v}
      return Api_MWResponseError()
    }
    set {response = .error(newValue)}
  }

  public var respLoadStoredKey: Api_LoadStoredKeyResp {
    get {
      if case .respLoadStoredKey(let v)? = response {return v}
      return Api_LoadStoredKeyResp()
    }
    set {response = .respLoadStoredKey(newValue)}
  }

  public var respCreateStoredKey: Api_CreateStoredKeyResp {
    get {
      if case .respCreateStoredKey(let v)? = response {return v}
      return Api_CreateStoredKeyResp()
    }
    set {response = .respCreateStoredKey(newValue)}
  }

  public var respImportPrivateKey: Api_ImportPrivateStoredKeyResp {
    get {
      if case .respImportPrivateKey(let v)? = response {return v}
      return Api_ImportPrivateStoredKeyResp()
    }
    set {response = .respImportPrivateKey(newValue)}
  }

  public var respImportMnemonic: Api_ImportMnemonicStoredKeyResp {
    get {
      if case .respImportMnemonic(let v)? = response {return v}
      return Api_ImportMnemonicStoredKeyResp()
    }
    set {response = .respImportMnemonic(newValue)}
  }

  public var respImportJson: Api_ImportJSONStoredKeyResp {
    get {
      if case .respImportJson(let v)? = response {return v}
      return Api_ImportJSONStoredKeyResp()
    }
    set {response = .respImportJson(newValue)}
  }

  public var respCreateAccountOfCoinAtPath: Api_CreateStoredKeyNewAccountAtPathResp {
    get {
      if case .respCreateAccountOfCoinAtPath(let v)? = response {return v}
      return Api_CreateStoredKeyNewAccountAtPathResp()
    }
    set {response = .respCreateAccountOfCoinAtPath(newValue)}
  }

  public var respExportPrivateKey: Api_ExportKeyStorePrivateKeyResp {
    get {
      if case .respExportPrivateKey(let v)? = response {return v}
      return Api_ExportKeyStorePrivateKeyResp()
    }
    set {response = .respExportPrivateKey(newValue)}
  }

  public var respExportMnemonic: Api_ExportKeyStoreMnemonicResp {
    get {
      if case .respExportMnemonic(let v)? = response {return v}
      return Api_ExportKeyStoreMnemonicResp()
    }
    set {response = .respExportMnemonic(newValue)}
  }

  public var respExportKeyStoreJson: Api_ExportKeyStoreJSONResp {
    get {
      if case .respExportKeyStoreJson(let v)? = response {return v}
      return Api_ExportKeyStoreJSONResp()
    }
    set {response = .respExportKeyStoreJson(newValue)}
  }

  public var respUpdateKeyStorePassword: Api_UpdateStoredKeyPasswordResp {
    get {
      if case .respUpdateKeyStorePassword(let v)? = response {return v}
      return Api_UpdateStoredKeyPasswordResp()
    }
    set {response = .respUpdateKeyStorePassword(newValue)}
  }

  public var respSignTransaction: Api_SignTransactionResp {
    get {
      if case .respSignTransaction(let v)? = response {return v}
      return Api_SignTransactionResp()
    }
    set {response = .respSignTransaction(newValue)}
  }

  public var respGetVersion: Api_GetVersionResp {
    get {
      if case .respGetVersion(let v)? = response {return v}
      return Api_GetVersionResp()
    }
    set {response = .respGetVersion(newValue)}
  }

  public var respValidate: Api_ValidateResp {
    get {
      if case .respValidate(let v)? = response {return v}
      return Api_ValidateResp()
    }
    set {response = .respValidate(newValue)}
  }

  public var respGetStoredKeyImportType: Api_GetKeyStoreSupportImportTypeResp {
    get {
      if case .respGetStoredKeyImportType(let v)? = response {return v}
      return Api_GetKeyStoreSupportImportTypeResp()
    }
    set {response = .respGetStoredKeyImportType(newValue)}
  }

  public var respGetStoredKeyExportType: Api_GetKeyStoreSupportExportTypeResp {
    get {
      if case .respGetStoredKeyExportType(let v)? = response {return v}
      return Api_GetKeyStoreSupportExportTypeResp()
    }
    set {response = .respGetStoredKeyExportType(newValue)}
  }

  public var respGenerateMnemonic: Api_GenerateMnemonicResp {
    get {
      if case .respGenerateMnemonic(let v)? = response {return v}
      return Api_GenerateMnemonicResp()
    }
    set {response = .respGenerateMnemonic(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Response: Equatable {
    case error(Api_MWResponseError)
    case respLoadStoredKey(Api_LoadStoredKeyResp)
    case respCreateStoredKey(Api_CreateStoredKeyResp)
    case respImportPrivateKey(Api_ImportPrivateStoredKeyResp)
    case respImportMnemonic(Api_ImportMnemonicStoredKeyResp)
    case respImportJson(Api_ImportJSONStoredKeyResp)
    case respCreateAccountOfCoinAtPath(Api_CreateStoredKeyNewAccountAtPathResp)
    case respExportPrivateKey(Api_ExportKeyStorePrivateKeyResp)
    case respExportMnemonic(Api_ExportKeyStoreMnemonicResp)
    case respExportKeyStoreJson(Api_ExportKeyStoreJSONResp)
    case respUpdateKeyStorePassword(Api_UpdateStoredKeyPasswordResp)
    case respSignTransaction(Api_SignTransactionResp)
    case respGetVersion(Api_GetVersionResp)
    case respValidate(Api_ValidateResp)
    case respGetStoredKeyImportType(Api_GetKeyStoreSupportImportTypeResp)
    case respGetStoredKeyExportType(Api_GetKeyStoreSupportExportTypeResp)
    case respGenerateMnemonic(Api_GenerateMnemonicResp)

  #if !swift(>=4.1)
    public static func ==(lhs: Api_MWResponse.OneOf_Response, rhs: Api_MWResponse.OneOf_Response) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.error, .error): return {
        guard case .error(let l) = lhs, case .error(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.respLoadStoredKey, .respLoadStoredKey): return {
        guard case .respLoadStoredKey(let l) = lhs, case .respLoadStoredKey(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.respCreateStoredKey, .respCreateStoredKey): return {
        guard case .respCreateStoredKey(let l) = lhs, case .respCreateStoredKey(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.respImportPrivateKey, .respImportPrivateKey): return {
        guard case .respImportPrivateKey(let l) = lhs, case .respImportPrivateKey(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.respImportMnemonic, .respImportMnemonic): return {
        guard case .respImportMnemonic(let l) = lhs, case .respImportMnemonic(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.respImportJson, .respImportJson): return {
        guard case .respImportJson(let l) = lhs, case .respImportJson(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.respCreateAccountOfCoinAtPath, .respCreateAccountOfCoinAtPath): return {
        guard case .respCreateAccountOfCoinAtPath(let l) = lhs, case .respCreateAccountOfCoinAtPath(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.respExportPrivateKey, .respExportPrivateKey): return {
        guard case .respExportPrivateKey(let l) = lhs, case .respExportPrivateKey(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.respExportMnemonic, .respExportMnemonic): return {
        guard case .respExportMnemonic(let l) = lhs, case .respExportMnemonic(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.respExportKeyStoreJson, .respExportKeyStoreJson): return {
        guard case .respExportKeyStoreJson(let l) = lhs, case .respExportKeyStoreJson(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.respUpdateKeyStorePassword, .respUpdateKeyStorePassword): return {
        guard case .respUpdateKeyStorePassword(let l) = lhs, case .respUpdateKeyStorePassword(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.respSignTransaction, .respSignTransaction): return {
        guard case .respSignTransaction(let l) = lhs, case .respSignTransaction(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.respGetVersion, .respGetVersion): return {
        guard case .respGetVersion(let l) = lhs, case .respGetVersion(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.respValidate, .respValidate): return {
        guard case .respValidate(let l) = lhs, case .respValidate(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.respGetStoredKeyImportType, .respGetStoredKeyImportType): return {
        guard case .respGetStoredKeyImportType(let l) = lhs, case .respGetStoredKeyImportType(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.respGetStoredKeyExportType, .respGetStoredKeyExportType): return {
        guard case .respGetStoredKeyExportType(let l) = lhs, case .respGetStoredKeyExportType(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.respGenerateMnemonic, .respGenerateMnemonic): return {
        guard case .respGenerateMnemonic(let l) = lhs, case .respGenerateMnemonic(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

public struct Api_MWResponseError {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var errorCode: String = String()

  public var errorMsg: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Api_MWRequest: @unchecked Sendable {}
extension Api_MWRequest.OneOf_Request: @unchecked Sendable {}
extension Api_MWResponse: @unchecked Sendable {}
extension Api_MWResponse.OneOf_Response: @unchecked Sendable {}
extension Api_MWResponseError: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "api"

extension Api_MWRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MWRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "param_load_stored_key"),
    2: .standard(proto: "param_create_stored_key"),
    3: .standard(proto: "param_import_private_key"),
    4: .standard(proto: "param_import_mnemonic"),
    5: .standard(proto: "param_import_json"),
    10: .standard(proto: "param_create_account_of_coin_at_path"),
    13: .standard(proto: "param_export_private_key"),
    14: .standard(proto: "param_export_private_key_of_path"),
    15: .standard(proto: "param_export_mnemonic"),
    16: .standard(proto: "param_export_key_store_json_of_address"),
    17: .standard(proto: "param_export_key_store_json_of_path"),
    18: .standard(proto: "param_update_key_store_password"),
    20: .standard(proto: "param_sign_transaction"),
    21: .standard(proto: "param_get_version"),
    22: .standard(proto: "param_validation"),
    23: .standard(proto: "param_get_stored_key_import_type"),
    24: .standard(proto: "param_get_stored_key_export_type"),
    25: .standard(proto: "param_generate_mnemonic"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Api_LoadStoredKeyParam?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .paramLoadStoredKey(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .paramLoadStoredKey(v)
        }
      }()
      case 2: try {
        var v: Api_CreateStoredKeyParam?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .paramCreateStoredKey(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .paramCreateStoredKey(v)
        }
      }()
      case 3: try {
        var v: Api_ImportPrivateStoredKeyParam?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .paramImportPrivateKey(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .paramImportPrivateKey(v)
        }
      }()
      case 4: try {
        var v: Api_ImportMnemonicStoredKeyParam?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .paramImportMnemonic(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .paramImportMnemonic(v)
        }
      }()
      case 5: try {
        var v: Api_ImportJSONStoredKeyParam?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .paramImportJson(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .paramImportJson(v)
        }
      }()
      case 10: try {
        var v: Api_CreateStoredKeyNewAccountAtPathParam?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .paramCreateAccountOfCoinAtPath(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .paramCreateAccountOfCoinAtPath(v)
        }
      }()
      case 13: try {
        var v: Api_ExportKeyStorePrivateKeyParam?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .paramExportPrivateKey(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .paramExportPrivateKey(v)
        }
      }()
      case 14: try {
        var v: Api_ExportKeyStorePrivateKeyOfPathParam?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .paramExportPrivateKeyOfPath(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .paramExportPrivateKeyOfPath(v)
        }
      }()
      case 15: try {
        var v: Api_ExportKeyStoreMnemonicParam?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .paramExportMnemonic(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .paramExportMnemonic(v)
        }
      }()
      case 16: try {
        var v: Api_ExportKeyStoreJSONOfAddressParam?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .paramExportKeyStoreJsonOfAddress(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .paramExportKeyStoreJsonOfAddress(v)
        }
      }()
      case 17: try {
        var v: Api_ExportKeyStoreJSONOfPathParam?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .paramExportKeyStoreJsonOfPath(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .paramExportKeyStoreJsonOfPath(v)
        }
      }()
      case 18: try {
        var v: Api_UpdateStoredKeyPasswordParam?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .paramUpdateKeyStorePassword(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .paramUpdateKeyStorePassword(v)
        }
      }()
      case 20: try {
        var v: Api_SignTransactionParam?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .paramSignTransaction(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .paramSignTransaction(v)
        }
      }()
      case 21: try {
        var v: Api_GetVersionParam?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .paramGetVersion(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .paramGetVersion(v)
        }
      }()
      case 22: try {
        var v: Api_ValidateParam?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .paramValidation(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .paramValidation(v)
        }
      }()
      case 23: try {
        var v: Api_GetKeyStoreSupportImportTypeParam?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .paramGetStoredKeyImportType(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .paramGetStoredKeyImportType(v)
        }
      }()
      case 24: try {
        var v: Api_GetKeyStoreSupportExportTypeParam?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .paramGetStoredKeyExportType(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .paramGetStoredKeyExportType(v)
        }
      }()
      case 25: try {
        var v: Api_GenerateMnemonicParam?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .paramGenerateMnemonic(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .paramGenerateMnemonic(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.request {
    case .paramLoadStoredKey?: try {
      guard case .paramLoadStoredKey(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .paramCreateStoredKey?: try {
      guard case .paramCreateStoredKey(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .paramImportPrivateKey?: try {
      guard case .paramImportPrivateKey(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .paramImportMnemonic?: try {
      guard case .paramImportMnemonic(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .paramImportJson?: try {
      guard case .paramImportJson(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .paramCreateAccountOfCoinAtPath?: try {
      guard case .paramCreateAccountOfCoinAtPath(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case .paramExportPrivateKey?: try {
      guard case .paramExportPrivateKey(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
    }()
    case .paramExportPrivateKeyOfPath?: try {
      guard case .paramExportPrivateKeyOfPath(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
    }()
    case .paramExportMnemonic?: try {
      guard case .paramExportMnemonic(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
    }()
    case .paramExportKeyStoreJsonOfAddress?: try {
      guard case .paramExportKeyStoreJsonOfAddress(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
    }()
    case .paramExportKeyStoreJsonOfPath?: try {
      guard case .paramExportKeyStoreJsonOfPath(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
    }()
    case .paramUpdateKeyStorePassword?: try {
      guard case .paramUpdateKeyStorePassword(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
    }()
    case .paramSignTransaction?: try {
      guard case .paramSignTransaction(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
    }()
    case .paramGetVersion?: try {
      guard case .paramGetVersion(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
    }()
    case .paramValidation?: try {
      guard case .paramValidation(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
    }()
    case .paramGetStoredKeyImportType?: try {
      guard case .paramGetStoredKeyImportType(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
    }()
    case .paramGetStoredKeyExportType?: try {
      guard case .paramGetStoredKeyExportType(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 24)
    }()
    case .paramGenerateMnemonic?: try {
      guard case .paramGenerateMnemonic(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 25)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_MWRequest, rhs: Api_MWRequest) -> Bool {
    if lhs.request != rhs.request {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_MWResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MWResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
    2: .standard(proto: "resp_load_stored_key"),
    3: .standard(proto: "resp_create_stored_key"),
    4: .standard(proto: "resp_import_private_key"),
    5: .standard(proto: "resp_import_mnemonic"),
    6: .standard(proto: "resp_import_json"),
    11: .standard(proto: "resp_create_account_of_coin_at_path"),
    14: .standard(proto: "resp_export_private_key"),
    15: .standard(proto: "resp_export_mnemonic"),
    16: .standard(proto: "resp_export_key_store_json"),
    17: .standard(proto: "resp_update_key_store_password"),
    19: .standard(proto: "resp_sign_transaction"),
    20: .standard(proto: "resp_get_version"),
    21: .standard(proto: "resp_validate"),
    22: .standard(proto: "resp_get_stored_key_import_type"),
    23: .standard(proto: "resp_get_stored_key_export_type"),
    24: .standard(proto: "resp_generate_mnemonic"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Api_MWResponseError?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .error(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .error(v)
        }
      }()
      case 2: try {
        var v: Api_LoadStoredKeyResp?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .respLoadStoredKey(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .respLoadStoredKey(v)
        }
      }()
      case 3: try {
        var v: Api_CreateStoredKeyResp?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .respCreateStoredKey(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .respCreateStoredKey(v)
        }
      }()
      case 4: try {
        var v: Api_ImportPrivateStoredKeyResp?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .respImportPrivateKey(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .respImportPrivateKey(v)
        }
      }()
      case 5: try {
        var v: Api_ImportMnemonicStoredKeyResp?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .respImportMnemonic(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .respImportMnemonic(v)
        }
      }()
      case 6: try {
        var v: Api_ImportJSONStoredKeyResp?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .respImportJson(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .respImportJson(v)
        }
      }()
      case 11: try {
        var v: Api_CreateStoredKeyNewAccountAtPathResp?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .respCreateAccountOfCoinAtPath(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .respCreateAccountOfCoinAtPath(v)
        }
      }()
      case 14: try {
        var v: Api_ExportKeyStorePrivateKeyResp?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .respExportPrivateKey(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .respExportPrivateKey(v)
        }
      }()
      case 15: try {
        var v: Api_ExportKeyStoreMnemonicResp?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .respExportMnemonic(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .respExportMnemonic(v)
        }
      }()
      case 16: try {
        var v: Api_ExportKeyStoreJSONResp?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .respExportKeyStoreJson(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .respExportKeyStoreJson(v)
        }
      }()
      case 17: try {
        var v: Api_UpdateStoredKeyPasswordResp?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .respUpdateKeyStorePassword(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .respUpdateKeyStorePassword(v)
        }
      }()
      case 19: try {
        var v: Api_SignTransactionResp?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .respSignTransaction(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .respSignTransaction(v)
        }
      }()
      case 20: try {
        var v: Api_GetVersionResp?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .respGetVersion(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .respGetVersion(v)
        }
      }()
      case 21: try {
        var v: Api_ValidateResp?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .respValidate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .respValidate(v)
        }
      }()
      case 22: try {
        var v: Api_GetKeyStoreSupportImportTypeResp?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .respGetStoredKeyImportType(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .respGetStoredKeyImportType(v)
        }
      }()
      case 23: try {
        var v: Api_GetKeyStoreSupportExportTypeResp?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .respGetStoredKeyExportType(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .respGetStoredKeyExportType(v)
        }
      }()
      case 24: try {
        var v: Api_GenerateMnemonicResp?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .respGenerateMnemonic(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .respGenerateMnemonic(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.response {
    case .error?: try {
      guard case .error(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .respLoadStoredKey?: try {
      guard case .respLoadStoredKey(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .respCreateStoredKey?: try {
      guard case .respCreateStoredKey(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .respImportPrivateKey?: try {
      guard case .respImportPrivateKey(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .respImportMnemonic?: try {
      guard case .respImportMnemonic(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .respImportJson?: try {
      guard case .respImportJson(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .respCreateAccountOfCoinAtPath?: try {
      guard case .respCreateAccountOfCoinAtPath(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case .respExportPrivateKey?: try {
      guard case .respExportPrivateKey(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
    }()
    case .respExportMnemonic?: try {
      guard case .respExportMnemonic(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
    }()
    case .respExportKeyStoreJson?: try {
      guard case .respExportKeyStoreJson(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
    }()
    case .respUpdateKeyStorePassword?: try {
      guard case .respUpdateKeyStorePassword(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
    }()
    case .respSignTransaction?: try {
      guard case .respSignTransaction(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
    }()
    case .respGetVersion?: try {
      guard case .respGetVersion(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
    }()
    case .respValidate?: try {
      guard case .respValidate(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
    }()
    case .respGetStoredKeyImportType?: try {
      guard case .respGetStoredKeyImportType(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
    }()
    case .respGetStoredKeyExportType?: try {
      guard case .respGetStoredKeyExportType(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
    }()
    case .respGenerateMnemonic?: try {
      guard case .respGenerateMnemonic(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 24)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_MWResponse, rhs: Api_MWResponse) -> Bool {
    if lhs.response != rhs.response {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_MWResponseError: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MWResponseError"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "errorCode"),
    2: .same(proto: "errorMsg"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.errorCode) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.errorMsg) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.errorCode.isEmpty {
      try visitor.visitSingularStringField(value: self.errorCode, fieldNumber: 1)
    }
    if !self.errorMsg.isEmpty {
      try visitor.visitSingularStringField(value: self.errorMsg, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_MWResponseError, rhs: Api_MWResponseError) -> Bool {
    if lhs.errorCode != rhs.errorCode {return false}
    if lhs.errorMsg != rhs.errorMsg {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
